[{"categories":["leetcode"],"content":"lc-1191","date":"2023-01-03","objectID":"/zh-cn/posts/lc-1191/","tags":["贪心","动态规划"],"title":"Lc 1191","uri":"/zh-cn/posts/lc-1191/"},{"categories":["leetcode"],"content":"Leetcode 1191,这题需要分类讨论，比较考思维，同时还考到前缀和 Leetcode 1191 给定一个整数数组 arr 和一个整数 k ，通过重复 k 次来修改数组。 例如，如果 arr = [1, 2] ， k = 3 ，那么修改后的数组将是 [1, 2, 1, 2, 1, 2] 。 返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 0，在这种情况下它的总和也是 0。 由于 结果可能会很大，需要返回的 10^9 + 7 的 模 。 示例 1： 输入：arr = [1,2], k = 3 输出：9 示例 2： 输入：arr = [1,-2,1], k = 5 输出：2 示例 3： 输入：arr = [-1,-2], k = 7 输出：0 提示： 1 \u003c= arr.length \u003c= 10^5 1 \u003c= k \u003c= 10^5 -10^4 \u003c= arr[i] \u003c= 10^4 Solution ","date":"2023-01-03","objectID":"/zh-cn/posts/lc-1191/:0:0","tags":["贪心","动态规划"],"title":"Lc 1191","uri":"/zh-cn/posts/lc-1191/"},{"categories":["leetcode"],"content":"dp ","date":"2023-01-03","objectID":"/zh-cn/posts/lc-1191/:1:0","tags":["贪心","动态规划"],"title":"Lc 1191","uri":"/zh-cn/posts/lc-1191/"},{"categories":["leetcode"],"content":"题目 1191. K 次串联后最大子数组之和 给定一个整数数组 arr 和一个整数 k ，通过重复 k 次来修改数组。 例如，如果 arr = [1, 2] ， k = 3 ，那么修改后的数组将是 [1, 2, 1, 2, 1, 2] 。 返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 0，在这种情况下它的总和也是 0。 由于 结果可能会很大，需要返回的 10^9 + 7 的 模 。 示例 1： 输入：arr = [1,2], k = 3 输出：9 示例 2： 输入：arr = [1,-2,1], k = 5 输出：2 示例 3： 输入：arr = [-1,-2], k = 7 输出：0 提示： 1 \u003c= arr.length \u003c= 10^5 1 \u003c= k \u003c= 10^5 -10^4 \u003c= arr[i] \u003c= 10^4 ","date":"2023-01-03","objectID":"/zh-cn/posts/lc-1191/:2:0","tags":["贪心","动态规划"],"title":"Lc 1191","uri":"/zh-cn/posts/lc-1191/"},{"categories":["leetcode"],"content":"解题 ","date":"2023-01-03","objectID":"/zh-cn/posts/lc-1191/:3:0","tags":["贪心","动态规划"],"title":"Lc 1191","uri":"/zh-cn/posts/lc-1191/"},{"categories":["leetcode"],"content":"方法一： 思路 代码 我们应该分类讨论k=1,k\u003e=2的情况，同时要考虑数组sum\u003e0, \u003c0的情况 typedef long long LL; const int MOD = 1e9 + 7; class Solution { public: int kConcatenationMaxSum(vector\u003cint\u003e\u0026 arr, int k) { // l max prefix, r max suffix, s means across the array max LL mx = 0, l = 0, r = 0, sum = 0, s = 0; for (int i = 0; i \u003c arr.size(); i ++ ) { sum += arr[i]; l = max(l, sum); s = max(s, 0ll) + arr[i]; mx = max(mx, s); if (i + 1 == arr.size()) r = s; } if (k == 1) return mx % MOD; if (sum \u003c 0) return max(mx, l + r) % MOD; return max(sum * (LL)(k - 2) + l + r, mx) % MOD; } }; ","date":"2023-01-03","objectID":"/zh-cn/posts/lc-1191/:3:1","tags":["贪心","动态规划"],"title":"Lc 1191","uri":"/zh-cn/posts/lc-1191/"},{"categories":["leetcode"],"content":"test","date":"2022-12-23","objectID":"/zh-cn/posts/lc-897/","tags":["贪心"],"title":"Leetcode 897","uri":"/zh-cn/posts/lc-897/"},{"categories":["leetcode"],"content":"Leetcode 897, 有思路，但是这一题要考虑，转换成链表要记录尾节点，然后如果没有头节点要加一个dummy 节点。 Leetcode 897 ","date":"2022-12-23","objectID":"/zh-cn/posts/lc-897/:0:0","tags":["贪心"],"title":"Leetcode 897","uri":"/zh-cn/posts/lc-897/"},{"categories":["leetcode"],"content":"方法 ","date":"2022-12-23","objectID":"/zh-cn/posts/lc-897/:1:0","tags":["贪心"],"title":"Leetcode 897","uri":"/zh-cn/posts/lc-897/"},{"categories":["leetcode"],"content":"dfs /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* tail; TreeNode* increasingBST(TreeNode* root) { TreeNode* dummy = new TreeNode(-1); tail = dummy; dfs(root); return dummy-\u003eright; } private: void dfs(TreeNode* root) { if (!root) return; dfs(root-\u003eleft); tail-\u003eright = root; root-\u003eleft = nullptr; tail = root; dfs(root-\u003eright); } }; ","date":"2022-12-23","objectID":"/zh-cn/posts/lc-897/:1:1","tags":["贪心"],"title":"Leetcode 897","uri":"/zh-cn/posts/lc-897/"},{"categories":["leetcode"],"content":"everyday","date":"2022-12-22","objectID":"/zh-cn/posts/lc-1799/","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/zh-cn/posts/lc-1799/"},{"categories":["leetcode"],"content":"Leetcode 1799, couldn’t get the solution Leetcode 1799 ","date":"2022-12-22","objectID":"/zh-cn/posts/lc-1799/:0:0","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/zh-cn/posts/lc-1799/"},{"categories":["leetcode"],"content":"Solution ","date":"2022-12-22","objectID":"/zh-cn/posts/lc-1799/:1:0","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/zh-cn/posts/lc-1799/"},{"categories":["leetcode"],"content":"dp + state compression 我们一共有2n个数，n最大为7，所以可以考虑用二进制位来枚举某个数是否被选取，从初始状态00…00开始，当某位被选择时，标为1. 从初始状态0开始搜索，每次选择2个数i, j进行配对，每次选了2个数后将位置i, j 置为1. mask^(1«i)^(1«j), 直到选取所有数后mask=11..11, 更新最大值，由于朴素dfs 会超时，所以要用状态压缩来记忆化搜索，对于当前的mask 状态来说，以前选取的顺序并不影响以后能够获得的最大值。 dp[mask] 代表当前状态mask下能获得的最大的分数 dfs + memo class Solution { public: int n; vector\u003cint\u003e dp; vector\u003cvector\u003cint\u003e\u003e gcds; vector\u003cint\u003e nums; int maxScore(vector\u003cint\u003e\u0026 _nums) { nums = _nums; n = nums.size(); dp.resize(1 \u003c\u003c n, -1); gcds.resize(n, vector\u003cint\u003e((n))); for (int i = 0; i \u003c n; i++) { for (int j = i + 1; j \u003c n; j++) { gcds[i][j] = GCD(nums[i], nums[j]); } } dfs(0, 1); return dp[0]; } private: int GCD(int a, int b) { return b == 0 ? a : GCD(b, a % b); } int dfs(int mask, int x) { if (x == n / 2 + 1) return 0; if (mask == (1 \u003c\u003c n) - 1) return 0; if (dp[mask] != -1) return dp[mask]; int sum = 0; for (int i = 0; i \u003c n; i++) { if (((mask \u003e\u003e i) \u0026 1) != 0) { continue; } for (int j = i + 1; j \u003c n; j++) { if (((mask \u003e\u003e j) \u0026 1) != 0) { continue; } sum = max(sum, x * gcds[i][j] + dfs(mask ^ (1 \u003c\u003c i) ^ (1 \u003c\u003c j), x + 1)); } } dp[mask] = sum; return sum; } }; ","date":"2022-12-22","objectID":"/zh-cn/posts/lc-1799/:1:1","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/zh-cn/posts/lc-1799/"},{"categories":["leetcode"],"content":"dp class Solution { public: int maxScore(vector\u003cint\u003e\u0026 nums) { int m = nums.size(); vector\u003cint\u003e dp(1 \u003c\u003c m, 0); vector\u003cvector\u003cint\u003e\u003e gcd_tmp(m, vector\u003cint\u003e(m, 0)); for (int i = 0; i \u003c m; ++i) { for (int j = i + 1; j \u003c m; ++j) { gcd_tmp[i][j] = gcd(nums[i], nums[j]); } } int all = 1 \u003c\u003c m; for (int s = 1; s \u003c all; ++s) { // __builtin_popcount return 1 count numbers in s int t = __builtin_popcount(s); // 奇数不做处理 if (t \u0026 1) { continue; } for (int i = 0; i \u003c m; ++i) { if ((s \u003e\u003e i) \u0026 1) { for (int j = i + 1; j \u003c m; ++j) { if ((s \u003e\u003e j) \u0026 1) { dp[s] = max(dp[s], dp[s ^ (1 \u003c\u003c i) ^ (1 \u003c\u003c j)] + t / 2 * gcd_tmp[i][j]); } } } } } return dp[all - 1]; } }; ","date":"2022-12-22","objectID":"/zh-cn/posts/lc-1799/:1:2","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/zh-cn/posts/lc-1799/"},{"categories":["leetcode"],"content":"test","date":"2022-12-21","objectID":"/zh-cn/posts/lc-1573/","tags":["贪心"],"title":"Leetcode 1573","uri":"/zh-cn/posts/lc-1573/"},{"categories":["leetcode"],"content":"Leetcode 1753, 没有想到思路 Leetcode 1753 ","date":"2022-12-21","objectID":"/zh-cn/posts/lc-1573/:0:0","tags":["贪心"],"title":"Leetcode 1573","uri":"/zh-cn/posts/lc-1573/"},{"categories":["leetcode"],"content":"方法 ","date":"2022-12-21","objectID":"/zh-cn/posts/lc-1573/:1:0","tags":["贪心"],"title":"Leetcode 1573","uri":"/zh-cn/posts/lc-1573/"},{"categories":["leetcode"],"content":"贪心 方法一：贪心 思路与算法 想通了就很好做，如果最大值大于其他两者之和，那么把其他两个用完都不会消耗完最大；如果小于的话，总是消去较大的那两个石头堆就行。 ","date":"2022-12-21","objectID":"/zh-cn/posts/lc-1573/:1:1","tags":["贪心"],"title":"Leetcode 1573","uri":"/zh-cn/posts/lc-1573/"},{"categories":["leetcode"],"content":"code class Solution { public: int maximumScore(int a, int b, int c) { int sum = a + b + c; int maxVal = max({a, b, c}); if (sum - maxVal \u003c maxVal) { return sum - maxVal; } else { return sum / 2; } } }; ","date":"2022-12-21","objectID":"/zh-cn/posts/lc-1573/:1:2","tags":["贪心"],"title":"Leetcode 1573","uri":"/zh-cn/posts/lc-1573/"},{"categories":null,"content":"About Me","date":"2019-08-02","objectID":"/zh-cn/about/","tags":null,"title":"About Me","uri":"/zh-cn/about/"},{"categories":null,"content":"E-mail tjbroadroad@163.com ","date":"2019-08-02","objectID":"/zh-cn/about/:0:0","tags":null,"title":"About Me","uri":"/zh-cn/about/"}]