[{"categories":["leetcode"],"content":"lc-1191","date":"2023-01-03","objectID":"/posts/lc-1191/","tags":["greedy","dp"],"title":"Lc 1191","uri":"/posts/lc-1191/"},{"categories":["leetcode"],"content":"Leetcode 1191, couldn’t get the solution Leetcode 1191 Given an integer array arr and an integer k, modify the array by repeating it k times. For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2]. Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0. As the answer can be very large, return the answer modulo 10^9 + 7. Example 1: Input: arr = [1,2], k = 3 Output: 9 Example 2: Input: arr = [1,-2,1], k = 5 Output: 2 Example 3: Input: arr = [-1,-2], k = 7 Output: 0 Constraints: 1 \u003c= arr.length \u003c= 10^5 1 \u003c= k \u003c= 10^5 -10^4 \u003c= arr[i] \u003c= 10^4 ","date":"2023-01-03","objectID":"/posts/lc-1191/:0:0","tags":["greedy","dp"],"title":"Lc 1191","uri":"/posts/lc-1191/"},{"categories":["leetcode"],"content":"Solution ","date":"2023-01-03","objectID":"/posts/lc-1191/:1:0","tags":["greedy","dp"],"title":"Lc 1191","uri":"/posts/lc-1191/"},{"categories":["leetcode"],"content":"dp We can try if k = 1, k = 2, k \u003e 2; and see whether the sum of array is \u003e= 0 or \u003c 0. typedef long long LL; const int MOD = 1e9 + 7; class Solution { public: int kConcatenationMaxSum(vector\u003cint\u003e\u0026 arr, int k) { // l max prefix, r max suffix, s means across the array max LL mx = 0, l = 0, r = 0, sum = 0, s = 0; for (int i = 0; i \u003c arr.size(); i ++ ) { sum += arr[i]; l = max(l, sum); s = max(s, 0ll) + arr[i]; mx = max(mx, s); if (i + 1 == arr.size()) r = s; } if (k == 1) return mx % MOD; if (sum \u003c 0) return max(mx, l + r) % MOD; return max(sum * (LL)(k - 2) + l + r, mx) % MOD; } }; ","date":"2023-01-03","objectID":"/posts/lc-1191/:1:1","tags":["greedy","dp"],"title":"Lc 1191","uri":"/posts/lc-1191/"},{"categories":["leetcode"],"content":"test","date":"2022-12-23","objectID":"/posts/lc-897/","tags":["Binary Search","dfs"],"title":"leetcode 897","uri":"/posts/lc-897/"},{"categories":["leetcode"],"content":"Leetcode 897, couldn’t get the solution Leetcode 897 ","date":"2022-12-23","objectID":"/posts/lc-897/:0:0","tags":["Binary Search","dfs"],"title":"leetcode 897","uri":"/posts/lc-897/"},{"categories":["leetcode"],"content":"Solution ","date":"2022-12-23","objectID":"/posts/lc-897/:1:0","tags":["Binary Search","dfs"],"title":"leetcode 897","uri":"/posts/lc-897/"},{"categories":["leetcode"],"content":"dfs /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* tail; TreeNode* increasingBST(TreeNode* root) { TreeNode* dummy = new TreeNode(-1); tail = dummy; dfs(root); return dummy-\u003eright; } private: void dfs(TreeNode* root) { if (!root) return; dfs(root-\u003eleft); tail-\u003eright = root; root-\u003eleft = nullptr; tail = root; dfs(root-\u003eright); } }; ","date":"2022-12-23","objectID":"/posts/lc-897/:1:1","tags":["Binary Search","dfs"],"title":"leetcode 897","uri":"/posts/lc-897/"},{"categories":["leetcode"],"content":"everyday","date":"2022-12-22","objectID":"/posts/lc-1799/","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/posts/lc-1799/"},{"categories":["leetcode"],"content":"Leetcode 1799, couldn’t get the solution Leetcode 1799 ","date":"2022-12-22","objectID":"/posts/lc-1799/:0:0","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/posts/lc-1799/"},{"categories":["leetcode"],"content":"Solution ","date":"2022-12-22","objectID":"/posts/lc-1799/:1:0","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/posts/lc-1799/"},{"categories":["leetcode"],"content":"dp + state compression We have a total of 2n numbers, and the maximum n is 7, so we can consider using binary bits to enumerate whether a certain number is selected. Starting from the initial state 00…00, when a certain bit is selected, it is marked as 1. From Initial state 0 starts searching, select 2 numbers i, j for pairing each time, set position i, j to 1 after selecting 2 numbers each time. mask^(1«i)^(1«j) , until mask=11..11 is selected after all the numbers are selected, the maximum value is updated. Since the simple dfs will time out, state compression is used to memorize the search. For the current mask state, the order of previous selection does not affect the future The maximum value obtained. dp[mask] represents the maximum score that can be obtained under the current state mask dfs + memo class Solution { public: int n; vector\u003cint\u003e dp; vector\u003cvector\u003cint\u003e\u003e gcds; vector\u003cint\u003e nums; int maxScore(vector\u003cint\u003e\u0026 _nums) { nums = _nums; n = nums.size(); dp.resize(1 \u003c\u003c n, -1); gcds.resize(n, vector\u003cint\u003e((n))); for (int i = 0; i \u003c n; i++) { for (int j = i + 1; j \u003c n; j++) { gcds[i][j] = GCD(nums[i], nums[j]); } } dfs(0, 1); return dp[0]; } private: int GCD(int a, int b) { return b == 0 ? a : GCD(b, a % b); } int dfs(int mask, int x) { if (x == n / 2 + 1) return 0; if (mask == (1 \u003c\u003c n) - 1) return 0; if (dp[mask] != -1) return dp[mask]; int sum = 0; for (int i = 0; i \u003c n; i++) { if (((mask \u003e\u003e i) \u0026 1) != 0) { continue; } for (int j = i + 1; j \u003c n; j++) { if (((mask \u003e\u003e j) \u0026 1) != 0) { continue; } sum = max(sum, x * gcds[i][j] + dfs(mask ^ (1 \u003c\u003c i) ^ (1 \u003c\u003c j), x + 1)); } } dp[mask] = sum; return sum; } }; ","date":"2022-12-22","objectID":"/posts/lc-1799/:1:1","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/posts/lc-1799/"},{"categories":["leetcode"],"content":"dp class Solution { public: int maxScore(vector\u003cint\u003e\u0026 nums) { int m = nums.size(); vector\u003cint\u003e dp(1 \u003c\u003c m, 0); vector\u003cvector\u003cint\u003e\u003e gcd_tmp(m, vector\u003cint\u003e(m, 0)); for (int i = 0; i \u003c m; ++i) { for (int j = i + 1; j \u003c m; ++j) { gcd_tmp[i][j] = gcd(nums[i], nums[j]); } } int all = 1 \u003c\u003c m; for (int s = 1; s \u003c all; ++s) { // __builtin_popcount return 1 count numbers in s int t = __builtin_popcount(s); // 奇数不做处理 if (t \u0026 1) { continue; } for (int i = 0; i \u003c m; ++i) { if ((s \u003e\u003e i) \u0026 1) { for (int j = i + 1; j \u003c m; ++j) { if ((s \u003e\u003e j) \u0026 1) { dp[s] = max(dp[s], dp[s ^ (1 \u003c\u003c i) ^ (1 \u003c\u003c j)] + t / 2 * gcd_tmp[i][j]); } } } } } return dp[all - 1]; } }; ","date":"2022-12-22","objectID":"/posts/lc-1799/:1:2","tags":["深度优先","状态压缩"],"title":"Leetcode 1799","uri":"/posts/lc-1799/"},{"categories":["leetcode"],"content":"test","date":"2022-12-21","objectID":"/posts/lc-1573/","tags":["greedy"],"title":"leetcode 1573","uri":"/posts/lc-1573/"},{"categories":["leetcode"],"content":"Leetcode 1753, couldn’t get the solution Leetcode 1753 ","date":"2022-12-21","objectID":"/posts/lc-1573/:0:0","tags":["greedy"],"title":"leetcode 1573","uri":"/posts/lc-1573/"},{"categories":["leetcode"],"content":"Solution ","date":"2022-12-21","objectID":"/posts/lc-1573/:1:0","tags":["greedy"],"title":"leetcode 1573","uri":"/posts/lc-1573/"},{"categories":["leetcode"],"content":"Greedy Assume a \u003c= b \u003c= c, so we have two conditions: a + b \u003c= c, then answer is a + b; a + b \u003e= c, then c always choose the larger one of a and b. Finally, a and b will became equal or different by 1. So a and c match k1 times, b and c match k2 times. k1 + k2 = c. The answer should be (k1 + k2) + ((a - k1) + (b - k1)) / 2 ","date":"2022-12-21","objectID":"/posts/lc-1573/:1:1","tags":["greedy"],"title":"leetcode 1573","uri":"/posts/lc-1573/"},{"categories":["leetcode"],"content":"code class Solution { public: int maximumScore(int a, int b, int c) { int sum = a + b + c; int maxVal = max({a, b, c}); if (sum - maxVal \u003c maxVal) { return sum - maxVal; } else { return sum / 2; } } }; ","date":"2022-12-21","objectID":"/posts/lc-1573/:1:2","tags":["greedy"],"title":"leetcode 1573","uri":"/posts/lc-1573/"},{"categories":null,"content":"About Me","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"E-mail tjbroadroad@163.com ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]